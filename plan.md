# AI 干预接口计划（退出 / 死循环场景）

## 1. 目标与边界

### 目标
- 当检测到 `exit/exit_group` 或“疑似死循环”时，自动进入 AI 干预流程：
  1) 获取当前上下文快照（寄存器、调用栈、伪代码/符号信息、syscall 上下文）。  
  2) 分析仿真失败原因（形成可追溯的诊断结论与证据）。  
  3) 自动补采关键内存信息（面向“验证假设/生成规则”的最小必要数据）。  
  4) 生成/更新规则（Lua hook 或插件配置），并自动重试验证。  

### 边界（避免过度设计/失控）
- 只在“明确失败/高风险卡死”时触发；默认不影响正常路径。
- 自动生成的规则必须“可回滚、可审计、最小影响范围”（优先针对 syscall+参数+调用栈特征做精确命中）。
- 重试次数与采集开销必须可配置、可限流，避免无限迭代和性能雪崩。

## 2. 触发条件与入口

### 触发条件
- 退出触发：捕获到 `exit/exit_group`（在真正退出前进入 AI 干预）。
- 死循环触发：`check_status` 判定“重复 syscall 上下文序列”且探测交互无法打破循环。

### 入口点（建议）
- Lua 侧 `entry.lua`：统一触发 AI 干预，能够拿到 syscall_name/num/args、shadowstack、并可调用 C 辅助接口。
- 退出场景：只做 `handle`，不做 `check_status`（避免误判导致无意义探测）。

## 3. 数据产出与目录规范（可追溯）

每次干预产生一个 `run_id`（时间戳+自增序号），写入 `rules/data/ai_runs/<run_id>/`：
- `snapshot.json`：结构化快照（syscall、寄存器、调用栈、解析信息索引、关键配置）。
- `regs.txt`：寄存器人类可读导出（便于快速定位）。
- `backtrace.txt`：调用栈地址列表 + 解析到的模块/函数名。
- `pseudocode/`：按地址导出伪代码片段（有 SFAnalysis 时），或记录“不可用原因”。
- `memory/`：关键内存 dump（每个对象一份：来源、地址、长度、读取方式、哈希）。
- `diagnosis.md`：AI 诊断报告（结论、证据、假设、待验证项、建议规则）。
- `rules_patch/`：生成的规则集合（syscall/*.lua、plugins/*、config 变更等）。
- `retry.log`：每轮重试的关键事件、判定结果、退出原因。

## 4. 核心流程（端到端）

### 阶段 A：冻结与快照（必须先做）
1. 进入干预时立刻“冻结”仿真路径（暂停/等待），确保上下文一致性。
2. 采集上下文：
   - syscall 上下文：syscall_name/num/args、时间戳、最近 N 条 syscall 序列摘要。
   - 寄存器：全量寄存器列表（或架构关键寄存器集合：PC/SP/LR/通用寄存器）。
   - 调用栈：shadowstack（ret_addr 列表），并对每帧做地址解析（模块/函数名/偏移）。
   - 伪代码：对调用栈 TopK 帧尝试拉取伪代码片段（若启用 SFAnalysis）。
3. 将快照写入 `ai_runs/<run_id>/`，并记录“哪些数据不可用以及原因”（例如 shadowstack 未开启、SFAnalysis 未配置）。

快照方式采用CRIU方式

### 阶段 B：原因分析（AI 推断 + 可验证假设）
1. 先用规则化启发式做快速分类（可解释、低成本）：
   - 正常退出 vs 异常退出（退出码/errno/信号模式）。
   - 资源缺失（文件/设备/权限/配置）导致退出或卡死。
   - I/O 等待型死循环（poll/select/accept/read 等阻塞与重复唤醒）。
   - 协议交互缺失（网络服务等待输入/握手）。
   - 逻辑自旋/锁等待（同一调用链重复触发同一 syscall 模式）。
2. 再做 AI 推断（LLM/本地模型/规则引擎均可）：
   - 依据：syscall 序列 + 调用栈 + 伪代码片段 + 返回值/errno 线索。
   - 产出：根因假设（可多条，按置信度排序）+ 每条假设的“需要补采的证据”列表。

### 阶段 C：自动补采关键内存信息（面向验证与生成规则）
1. 从以下来源提取“候选地址/对象”：
   - syscall 参数中的指针/长度对（如 buf/len、path 指针、sockaddr、结构体指针）。
   - 寄存器中的关键指针（SP 附近栈帧、关键寄存器中可能的对象指针）。
   - 伪代码中出现的全局/结构体字段访问（可通过 SFAnalysis 的变量/偏移线索辅助）。
2. 按“最小必要”策略读取内存：
   - 先小块读取 + 哈希；只有当需要进一步解析时再扩大范围。
   - 尝试将内存解析成：字符串（路径/HTTP 头/错误信息）、结构体字段、状态机枚举等。
3. 形成 `memory/` 下的证据文件，并在 `snapshot.json` 里建立索引（来源->地址->大小->用途）。

### 阶段 D：生成规则（可回滚、精确命中、带观测）
1. 选择规则载体（按成本/可控性排序）：
   - syscall 级 hook（`syscall/<name>.lua`）：拦截/改返回值/改 guest 内存。
   - 插件化能力（如 fakefile/net 等）：集中管理、可复用。
   - 仅日志规则（先观察）：在不改变行为的前提下补充更多证据。
2. 规则生成原则：
   - 条件精确：至少用 syscall_name + 关键参数 +（可选）调用栈特征做匹配。
   - 变更最小：优先“只改一个点”，避免大范围篡改导致误伤。
   - 可验证：规则中输出关键日志/计数器，便于确认是否命中以及命中次数。
3. 输出 `rules_patch/`，并在 `diagnosis.md` 中写清：
   - 规则意图、预期影响、风险点、回滚方式。

### 阶段 E：自动重试与评估（闭环）
1. 重试执行：
   - 使用同一输入与环境，加载新规则进行一次“短周期重试”（先验证是否打破卡死/退出）。
2. 评估指标（至少满足其一）：
   - 前进性：重复序列消失、syscall 序列出现新分支、关键状态持续变化。
   - 目标服务可用性：探测交互成功（如 80/443 有响应或连接状态变化）。
   - 稳定性：未引入新的异常退出/更严重卡死。
3. 迭代策略：
   - 失败则回到“阶段 B/C”，补采更精准证据并生成更窄的规则。
   - 设置硬限制：最大重试轮数、单轮时间预算、最大规则变更数。
4. 成功策略：
   - 将最终规则标记为 `stable`，并生成“规则说明 + 适用条件 + 已知副作用”文档片段。

## 5. 典型根因 -> 规则策略库（建议先覆盖高频）

- 文件/配置缺失：
  - 证据：open/openat 返回 -ENOENT；伪代码显示读取配置/证书/固件文件。
  - 规则：fakefile 插件提供缺失文件；或在特定路径上返回“伪造内容”。
- 权限/能力不足：
  - 证据：-EACCES/-EPERM；伪代码显示 setuid/capability/设备节点访问。
  - 规则：对特定 ioctl/prctl/capset 做兼容返回；或模拟设备信息。
- 网络交互缺失导致等待：
  - 证据：accept/poll/select 重复；调用栈落在连接处理/握手路径。
  - 规则：触发探测交互；必要时对特定 recv/read 注入输入数据（基于内存/协议格式）。
- 自旋/死循环：
  - 证据：短序列重复；backtrace 稳定；伪代码显示状态变量不变。
  - 规则：定位状态变量地址并修正；或对某 syscall 返回值做“推进状态”的最小修改。

## 6. 里程碑拆解（建议按增量交付）

1) M1：干预触发 + 快照落盘（寄存器/调用栈/伪代码索引/基础日志）。  
2) M2：死循环/退出两类场景的“最小诊断报告”自动生成（可解释）。  
3) M3：自动补采内存证据（字符串/小块 dump/结构体候选），并能被诊断引用。  
4) M4：规则模板库（文件缺失/网络等待/权限不足/自旋推进）+ 精确命中策略。  
5) M5：自动重试编排（轮次限制、回滚、评估指标、产出可追溯结果）。  
6) M6：稳定化与可运维：配置化、性能限流、失败兜底（人工确认/半自动模式）。  

## 7. 风险与防护（务必提前定义）
- 误判/过拟合：规则命中条件过宽导致“看似修复但破坏真实行为”；必须默认精确匹配并限制命中次数。
- 不可用数据源：shadowstack/SFAnalysis 未启用时的降级路径（仅 syscall+寄存器+最小内存证据）。
- 安全与隐私：内存 dump 可能包含敏感信息；需要脱敏/长度限制/按白名单采集。
- 迭代失控：必须有最大轮次/时间预算/规则变更预算；超限切人工确认。
