# rules_examples/config/env.example
# 说明：
# - 建议把真实密钥写到本地的 config/env（该文件默认被 .gitignore 忽略）
# - 本文件仅作为“可提交的模板”
#
# 语法：
# - 支持 KEY=VALUE 或 export KEY=VALUE
# - 支持注释行（# ...）与空行

# ----------------------------
# 外部 AI/LLM（OpenAI 兼容 API）
# ----------------------------
OPENAI_API_KEY=
OPENAI_BASE_URL=https://api.openai.com/v1
OPENAI_MODEL=gpt-4o-mini

# ----------------------------
# SFEmu AI 干预框架（base/ai.lua）
# ----------------------------
# 1=开启（默认建议开启：仅在 exit/死循环触发时生效）
SFEMU_AI_ENABLE=1

# 自动继续（仅当本轮应用了 fix 规则时才会自动继续）
SFEMU_AI_AUTO_CONTINUE=1

# 是否自动应用 rules_patch（默认 1）
SFEMU_AI_APPLY_RULES=1

# 是否覆盖已有 syscall/<name>.lua（默认 0；开启会先备份）
SFEMU_AI_OVERWRITE_RULES=0

# 验证窗口：应用修复规则后，继续运行 N 个 syscall 即认为“稳定”，并导出 stable_rules
SFEMU_AI_VERIFY_SYSCALLS=2048

# 导出 stable_rules 后自动关闭 AI（默认 1）
SFEMU_AI_DISABLE_AFTER_STABLE=1

# 在“关键 syscall 返回错误”时触发 AI 干预并在该 syscall 点尝试重试（避免走到 exit 才介入）。
# - 1=开启（默认）
# - 0=关闭（仅在 exit/死循环触发）
SFEMU_AI_REPAIR_ON_ERROR=1

# 触发范围：逗号分隔的 syscall 名称（默认：open,openat,access,ioctl）
SFEMU_AI_REPAIR_SYSCALLS=open,openat,access,ioctl

# 触发错误码：逗号分隔 errno（默认：1,2,13,19,22,25）
SFEMU_AI_REPAIR_ERRNOS=1,2,13,19,22,25

# exit/exit_group 场景：当 AI 已应用“修复型规则”且选择自动继续时，
# 是否触发 QEMU 自身 re-exec 重新运行目标（用于“重新加载镜像/重试验证”）。
# - 1=开启（默认开启）
# - 0=关闭（保持原行为：exit 会直接结束进程）
SFEMU_AI_REEXEC_ON_EXIT_FIX=1

# re-exec 最大次数限制（防止修复无效导致无限重启），默认 3；设置为 0 表示禁用 re-exec。
SFEMU_REEXEC_MAX=3

# 外部工具命令（可选）：若设置，将执行：
#   $SFEMU_AI_CMD <snapshot.json> <rules_patch_dir> <env_path>
SFEMU_AI_CMD=

# 内置“类 MCP”：未设置 SFEMU_AI_CMD 时，自动调用 OpenAI 兼容 API 生成规则
SFEMU_AI_MCP_ENABLE=0
# SFEMU_AI_MCP_PY=python3
# SFEMU_AI_MCP_SCRIPT=./rules_examples/plugins/ai/ai_mcp_openai.py

# MCP 工具调用（可选）：允许模型调用“受限工具”读取/修改固件 rootfs（用于自动干预、减少手写规则）。
# - 默认关闭：避免误写宿主机文件系统或意外执行命令
# - 建议组合开启：SFEMU_AI_MCP_TOOLS_ENABLE=1 + SFEMU_AI_MCP_ACTIONS_ENABLE=1
SFEMU_AI_MCP_TOOLS_ENABLE=0
SFEMU_AI_MCP_ACTIONS_ENABLE=0

# 工具调用最大轮数（避免模型陷入无限循环），默认 8
SFEMU_AI_MCP_MAX_TOOL_STEPS=8

# 写入安全根目录（可选）：留空则自动检测（推荐留空）
# - chroot(rootfs) 内通常为 /
# - 未 chroot 场景会尝试推导为 <rootfs>（即包含 rules_examples 的目录）
SFEMU_AI_MCP_SAFE_ROOT=

# 允许执行 shell 白名单命令（默认关闭，强烈不建议在批量跑时开启）
SFEMU_AI_MCP_SHELL_ENABLE=0

# 允许 AI 执行受控的“网络补齐”动作（net_* 工具，默认关闭）
# 说明：仅建议在 Docker/隔离环境中开启；脚本内部仍会做“容器检测”以降低误伤风险。
SFEMU_AI_MCP_NET_ENABLE=0

# net_* 工具使用的 ip 可执行文件路径（可选）
# - lab/run_batch_001.sh 默认会把宿主（容器）里的 /usr/sbin/ip bind mount 到 rootfs 的 /sfemu_tools/ip
SFEMU_AI_MCP_IP_BIN=/sfemu_tools/ip

# 若处于 chroot(rootfs) 场景，/.dockerenv 等容器标记文件不可见，容器检测可能失败；
# 可显式声明“当前在隔离环境内”，允许 net_* 工具生效。
SFEMU_AI_MCP_ASSUME_CONTAINER=0

# sleep_loop 自愈（不依赖外部 API）：默认开启
SFEMU_AI_MCP_AUTOFIX_SLEEP_LOOP=1
# 自愈策略里默认补齐的 LAN（可按固件调整）
SFEMU_AI_LAN_IFACE=br0
SFEMU_AI_LAN_CIDR=192.168.1.1/24

# MCP prompt：是否附带“调用栈对应的伪C代码”（来自 cache/ai_runs/.../pseudocode/*.txt）。
# 默认开启，但会严格截断避免 prompt 过大；可按需调小/关闭以减少 tokens 与 API 成本。
SFEMU_AI_MCP_INCLUDE_PSEUDOCODE=1
SFEMU_AI_MCP_PSEUDOCODE_FRAMES=4
SFEMU_AI_MCP_PSEUDOCODE_MAX_BYTES=32768
SFEMU_AI_MCP_PSEUDOCODE_FILE_BYTES=8192

# ----------------------------
# 一键无人值守（推荐在批量跑固件时使用）
# ----------------------------
# auto_ai=1：遇到异常退出/死循环/长时间无 syscall 时：
# - 不再提示 “输入 YES 继续运行”
# - 自动触发 AI 干预（即使 SFEMU_AI_ENABLE=0 也会强制启用）
auto_ai=0

# ----------------------------
# 死循环/长睡眠循环检测（entry.lua）
# ----------------------------
# 长睡眠循环阈值：select/pselect6(nfds=0) 重复 N 次后触发 AI（避免一直卡住但不被 deadloop/idle watchdog 捕捉）
SFEMU_SLEEP_LOOP_SELECT_REPEATS=2
# 兼容旧名：仅 pselect6(nfds=0) 的重复阈值
SFEMU_SLEEP_LOOP_PSELECT6_REPEATS=2

# 未映射 syscall 是否也记录（调试用；默认关闭以减少噪声）
SFEMU_LOG_UNKNOWN_SYSCALLS=0
